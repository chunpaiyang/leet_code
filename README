
## 2018.06.06
寫完 732., 736. 兩題學到
1. leet code 解題最一開始要先想簡單的 test case，並初步的拆解問題
2. leet code 下一步在想複雜的 test case，經典的 test case 可以 cover 到許多問題的。

3. 把 test case 轉成可循序動作的算法，一時間可能會有多個想法。而每個想法都需要驗證，因此盡可能去選擇可能是答案的想法(一開始的抉擇錯誤就會導致 30 分鐘到 1 個小時消失)

4. 在 1,2 步驟邊想 test case 的同時，在步驟 3. 你會需要決定 data structure / 表示法。一個不好的 data strucutre 會影響效能，有可能因此過不了。此外解題過程中的表示法(有點像代數)會嚴重的影響思路。

5. 算法上要注意不要算多餘的東西，譬如題目要 num，那麼不一定要把整個 array 的data 都準備好。只要專注於算出 num 就好。

6. 有些需要創造力/tricky 的想法和作法 e.g. 732.。但我覺得基本上把圖畫出來，看著圖想到什麼 ticky 的方式都可以列入考量。
NOTE: 其實我 732. 是沒解出來的，只是 copy/paste 上面的答案。

## 2018.06.17
寫完 773.sliding puzzle 學到
7. 儘可能的運用題目的條件。像是 773.SlidingPuzzle 非常的難，可是題目跟你說 input matrix 就是一個 2x3 的 array 也不會改變大小和可能的值的集合，你就會想到暴力的把它解開就可以了...整個問題的難度就可以下降很多。甚至因為知道全部的解只有 6! 這麼多，如果在意 run time 的人甚至可以把 hash 直接嵌入到 code 中省去算 hash table 的時間。


## 2018.06.30
寫完 not_leet_code/LikeNumber 學到
8. 有些問題是其他"經典問題"的變形。譬如這題就是 permutation 遞迴算法的變形。

寫完 32.LongestValidParentheses 學到
9. 有些問題需要"深入"的了解問題本身，如當問題是回答"連續"的長度，必然會處理到哪時候重設這個長度的 counter，哪時候要繼續繼承之前的 counter。
另外自己產生 cases 驗證，在實戰中是非常重要的一件事情。這一題我沒特別這麼做，submit 六次才成功過關。

## 2018.07.01
寫完 778.SwiminRisingWater 學到
10. 這題一樣用到很基本的解題方法，先用小的 example 如 3x3 or 4x4 的來想。然後一樣會跑出某些想法，然後就會發現這些想法所需要的資料結構和演算法。
11. 發現 heap min 為 std library of python/c++。若題目要全盤找最小，就可以考慮用它。
